"""bin-to-wheel: Package pre-built binaries into Python wheels."""

import argparse
import base64
import csv
import hashlib
import io
import os
import platform
import re
import stat
import sys
import zipfile
from pathlib import Path

__version__ = "0.1.0"

# ---------------------------------------------------------------------------
# Epic 1: Name normalization
# ---------------------------------------------------------------------------

def normalize_package_name(name: str) -> str:
    """Normalize a package name per PEP 503: lowercase, hyphens/dots → underscores."""
    return re.sub(r"[-.]", "_", name).lower()


# ---------------------------------------------------------------------------
# Epic 2: RECORD hash computation
# ---------------------------------------------------------------------------

def compute_file_hash(content: bytes) -> str:
    """SHA-256 hash of content, URL-safe base64 encoded with padding stripped."""
    digest = hashlib.sha256(content).digest()
    return base64.urlsafe_b64encode(digest).rstrip(b"=").decode("ascii")


# ---------------------------------------------------------------------------
# Epic 5: Platform tag handling
# ---------------------------------------------------------------------------

PLATFORM_TAGS: dict[str, str] = {
    "linux-x86_64": "manylinux_2_17_x86_64",
    "macos-arm64": "macosx_11_0_arm64",
    "macos-x86_64": "macosx_10_15_x86_64",
    "windows-x64": "win_amd64",
}

# All known raw tags (values from PLATFORM_TAGS)
_KNOWN_RAW_TAGS = set(PLATFORM_TAGS.values())


def resolve_platform_tag(tag: str) -> str:
    """Resolve a friendly name or raw PEP 427 platform tag."""
    if tag in PLATFORM_TAGS:
        return PLATFORM_TAGS[tag]
    if tag in _KNOWN_RAW_TAGS or _looks_like_raw_tag(tag):
        return tag
    raise ValueError(
        f"Unknown platform: {tag!r}. "
        f"Use one of: {', '.join(sorted(PLATFORM_TAGS.keys()))} "
        f"or a raw PEP 427 tag."
    )


def _looks_like_raw_tag(tag: str) -> bool:
    """Heuristic: raw tags contain underscores and look like manylinux/macosx/win."""
    return bool(re.match(r"^(manylinux|musllinux|macosx|win|linux)", tag))


def detect_current_platform() -> str:
    """Detect the current platform and return a wheel platform tag."""
    system = platform.system().lower()
    machine = platform.machine().lower()

    if system == "linux":
        if machine == "x86_64":
            return "manylinux_2_17_x86_64"
        return f"linux_{machine}"
    elif system == "darwin":
        if machine == "arm64":
            return "macosx_11_0_arm64"
        return "macosx_10_15_x86_64"
    elif system == "windows":
        if machine in ("amd64", "x86_64"):
            return "win_amd64"
        return f"win_{machine}"
    else:
        return f"{system}_{machine}"


# ---------------------------------------------------------------------------
# Epic 3: Generated file content
# ---------------------------------------------------------------------------

def generate_init_py(version: str, binary_name: str) -> str:
    """Generate __init__.py for the installed wheel package."""
    return f'''\
"""Auto-generated by bin-to-wheel."""

import os
import stat
import subprocess
import sys
from pathlib import Path

__version__ = "{version}"

BINARY_NAME = "{binary_name}"


def get_binary_path() -> Path:
    """Return the path to the bundled binary."""
    return Path(__file__).parent / "bin" / BINARY_NAME


def main():
    """Run the bundled binary, passing through all arguments."""
    binary = get_binary_path()

    # Fix execute permission if stripped by installer
    if not os.access(binary, os.X_OK):
        binary.chmod(binary.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    if sys.platform != "win32":
        os.execvp(str(binary), [str(binary)] + sys.argv[1:])
    else:
        raise SystemExit(subprocess.call([str(binary)] + sys.argv[1:]))
'''


def generate_main_py() -> str:
    """Generate __main__.py for python -m support."""
    return "from . import main\n\nmain()\n"


def generate_metadata(
    name: str,
    version: str,
    description: str | None = None,
    author: str | None = None,
    license_name: str | None = None,
    url: str | None = None,
    long_description: str | None = None,
) -> str:
    """Generate PEP 566 METADATA file content."""
    lines = [
        "Metadata-Version: 2.1",
        f"Name: {name}",
        f"Version: {version}",
    ]
    if description:
        lines.append(f"Summary: {description}")
    if url:
        lines.append(f"Home-page: {url}")
    if author:
        lines.append(f"Author: {author}")
    if license_name:
        lines.append(f"License: {license_name}")
    if long_description:
        lines.append("Description-Content-Type: text/markdown")
        lines.append("")
        lines.append(long_description)
    else:
        lines.append("")
    return "\n".join(lines) + "\n"


def generate_wheel_metadata(platform_tag: str) -> str:
    """Generate PEP 427 WHEEL metadata file content."""
    return (
        "Wheel-Version: 1.0\n"
        f"Generator: bin-to-wheel {__version__}\n"
        "Root-Is-Purelib: false\n"
        f"Tag: py3-none-{platform_tag}\n"
    )


def generate_entry_points(entry_point: str, import_name: str) -> str:
    """Generate entry_points.txt content."""
    return f"[console_scripts]\n{entry_point} = {import_name}:main\n"


def generate_record(
    files: dict[str, bytes],
    record_path: str | None = None,
) -> str:
    """Generate RECORD file content per PEP 376."""
    buf = io.StringIO()
    writer = csv.writer(buf, lineterminator="\n")
    for filepath, content in sorted(files.items()):
        h = compute_file_hash(content)
        writer.writerow([filepath, f"sha256={h}", str(len(content))])
    if record_path:
        writer.writerow([record_path, "", ""])
    return buf.getvalue()


# ---------------------------------------------------------------------------
# Epic 4: Wheel ZIP assembly
# ---------------------------------------------------------------------------

def build_wheel(
    binary_path: Path,
    output_dir: Path,
    name: str,
    version: str,
    platform_tag: str,
    entry_point: str | None = None,
    description: str | None = None,
    author: str | None = None,
    license_name: str | None = None,
    url: str | None = None,
    long_description: str | None = None,
) -> Path:
    """Build a wheel file from a pre-built binary. Returns the output path."""
    binary_path = Path(binary_path)
    output_dir = Path(output_dir)

    if not binary_path.exists():
        raise FileNotFoundError(f"Binary not found: {binary_path}")

    import_name = normalize_package_name(name)
    # Binary keeps its original filename (preserves .exe on Windows)
    binary_name = binary_path.name
    dist_info = f"{import_name}-{version}.dist-info"

    # Collect all files (path in zip → bytes)
    wheel_files: dict[str, bytes] = {}

    # Package files
    wheel_files[f"{import_name}/__init__.py"] = generate_init_py(version, binary_name).encode()
    wheel_files[f"{import_name}/__main__.py"] = generate_main_py().encode()
    wheel_files[f"{import_name}/bin/{binary_name}"] = binary_path.read_bytes()

    # Dist-info files
    wheel_files[f"{dist_info}/METADATA"] = generate_metadata(
        name=name,
        version=version,
        description=description,
        author=author,
        license_name=license_name,
        url=url,
        long_description=long_description,
    ).encode()
    wheel_files[f"{dist_info}/WHEEL"] = generate_wheel_metadata(platform_tag).encode()

    # entry_point controls console_scripts name only (e.g., "erpl-adt")
    if entry_point:
        wheel_files[f"{dist_info}/entry_points.txt"] = generate_entry_points(
            entry_point, import_name
        ).encode()

    # RECORD (must be last — references all other files)
    record_path = f"{dist_info}/RECORD"
    record_content = generate_record(wheel_files, record_path=record_path)
    wheel_files[record_path] = record_content.encode()

    # Build the ZIP
    wheel_filename = f"{import_name}-{version}-py3-none-{platform_tag}.whl"
    wheel_path = output_dir / wheel_filename

    with zipfile.ZipFile(wheel_path, "w", compression=zipfile.ZIP_DEFLATED) as zf:
        for filepath, content in sorted(wheel_files.items()):
            info = zipfile.ZipInfo(filepath)
            # Set executable permissions for the binary
            if filepath == f"{import_name}/bin/{binary_name}":
                info.external_attr = (0o100755 << 16)
            else:
                info.external_attr = (0o100644 << 16)
            zf.writestr(info, content)

    return wheel_path


# ---------------------------------------------------------------------------
# Epic 6: CLI
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        prog="bin-to-wheel",
        description="Package a pre-built binary into a Python wheel.",
    )
    parser.add_argument("--name", required=True, help="Package name (e.g. erpl-adt)")
    parser.add_argument("--version", required=True, help="Package version")
    parser.add_argument("--binary", required=True, help="Path to the binary to package")
    parser.add_argument("--output-dir", default="dist", help="Output directory (default: dist)")
    parser.add_argument("--entry-point", help="Console script entry point name")
    parser.add_argument("--description", help="Package description")
    parser.add_argument("--author", help="Package author")
    parser.add_argument("--license", dest="license_name", help="License identifier")
    parser.add_argument("--url", help="Project URL")
    parser.add_argument("--readme", help="Path to README file for long description")

    platform_group = parser.add_mutually_exclusive_group(required=True)
    platform_group.add_argument("--platform", help="Platform tag (friendly name or raw)")
    platform_group.add_argument("--auto-platform", action="store_true", help="Auto-detect platform")

    args = parser.parse_args()

    binary_path = Path(args.binary)
    if not binary_path.exists():
        print(f"Error: binary not found: {binary_path}", file=sys.stderr)
        raise SystemExit(1)

    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    if args.auto_platform:
        platform_tag = detect_current_platform()
    else:
        try:
            platform_tag = resolve_platform_tag(args.platform)
        except ValueError as e:
            print(f"Error: {e}", file=sys.stderr)
            raise SystemExit(1)

    long_description = None
    if args.readme:
        readme_path = Path(args.readme)
        if readme_path.exists():
            long_description = readme_path.read_text()

    try:
        wheel_path = build_wheel(
            binary_path=binary_path,
            output_dir=output_dir,
            name=args.name,
            version=args.version,
            platform_tag=platform_tag,
            entry_point=args.entry_point,
            description=args.description,
            author=args.author,
            license_name=args.license_name,
            url=args.url,
            long_description=long_description,
        )
        print(wheel_path)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        raise SystemExit(1)
